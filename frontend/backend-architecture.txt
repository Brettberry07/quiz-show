Base
Base URL: http://localhost:5200 (default)
Content-Type: application/json
Validation: Global ValidationPipe (whitelist: true, forbidNonWhitelisted: true, transform: true). Extra fields cause 400.
Auth & Tokens
Bearer auth header: Authorization: Bearer <access_token>
Login autoâ€‘registers a user if not found.
Routes (public)
GET /

Health check.
Response: { message, status, version }
POST /login

Guard: BodyRequiredGuard
Body:
username (string, required)
Response:
{ access_token, refresh_token, token_type: "bearer", user_id, message }
PATCH /auth/refresh

Guard: BodyRequiredGuard
Body:
refresh_token (string, required)
Response:
{ access_token, refresh_token, token_type: "bearer", message }
Routes (auth required)
GET /auth/me

Requires Bearer token
Response:
{ message, status: 200, data: { id, username, role } }
Users (auth required)
GET /users

Response:
{ message, status, data: [{ id, username, createdAt }] }
If none: { message: "No users found", status: 404 }
GET /users/me

Response:
{ message, status, data: { id, username, createdAt } }
If missing: { message, status: 404, data: undefined }
DELETE /users/:uuid

Response:
{ message, status, data: { id, username } }
If missing: { message, status: 404, data: undefined }
Quiz (auth required)
All /quiz routes require Bearer token.
Note: Quiz data is in-memory, so data resets on server restart.

Shared types
QuestionType

"MULTIPLE_CHOICE" or "TRUE_FALSE"
Create/Update question fields

text (string, required)
type (QuestionType, required)
timeLimitSeconds (number, min 5)
pointsMultiplier (number, min 0.1)
options (string[], min length 2)
correctOptionIndex (int, >= 0, must be < options.length)
Routes
POST /quiz

Body:
title (string, required)
questions (array of CreateQuestionDto, min length 1)
Response:
{ message, status: 201, data: quizSummary }
quizSummary:
{ id, title, hostId, questionCount, createdAt, updatedAt }
GET /quiz

Response:
{ message, status: 200, data: quizSummary[] }
GET /quiz/my

Response:
{ message, status: 200, data: quizSummary[] }
GET /quiz/stats

Response:
{ message, status: 200, data: { totalQuizzes, totalQuestions, averageQuestionsPerQuiz } }
GET /quiz/:id/validate

Response:
{ message, status: 200, data: { valid: boolean, reason?: string } }
GET /quiz/:id

Response:
{ message, status: 200, data: quizForClient }
quizForClient:
{ id, title, hostId, createdAt, updatedAt, questions: [...] }
If requester is host: each question includes correctOptionIndex
If not host: correctOptionIndex is omitted
PATCH /quiz/:id

Body (partial):
title?: string
questions?: UpdateQuestionDto[] (each needs id, and any fields to update)
Response:
{ message, status: 200, data: quizSummary }
Errors:
403 if not host
404 if quiz or question not found
400 for invalid fields
POST /quiz/:id/questions

Body: AddQuestionDto
Response:
{ message, status: 201, data: safeQuestion }
safeQuestion: excludes correctOptionIndex
Errors:
403 if not host
POST /quiz/game/:pin/questions

Purpose: player contributes one question while game is still in lobby.
Body: AddQuestionDto
Response:
{ message, status: 201, data: safeQuestion }
Errors:
400 if game started, player not in game, or already contributed
DELETE /quiz/:id/questions/:questionId

Response:
{ message, status: 200, data: { removed: boolean } }
Errors:
403 if not host
DELETE /quiz/:id

Response:
{ message, status: 200, data: quizSummary }
Errors:
403 if not host
404 if not found
Game (no REST endpoints exposed)
Game functionality exists in services and appears intended for websocket usage, but there are no HTTP controllers for game creation/join/answer at present. Frontend should rely on REST only for auth, users, and quiz.